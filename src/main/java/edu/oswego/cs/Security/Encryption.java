package edu.oswego.cs.Security;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;
import java.util.Arrays;

public class Encryption {

    public int rsaKeySize = 2048;
    public int keySize = 256;
    public int ivSize = 16;

    // Referred to here: https://github.com/firatkucuk/diffie-hellman-helloworld/tree/main
    private PrivateKey privateKey;
    private PublicKey publicKey;

    private SecretKey secretKey;

    public PublicKey getPublicKey() {
        return this.publicKey;
    }

    /**
     * Generate the AES secret key.  When someone connects, they will send the server their public key.  If a secret key hasn't been generated yet,
     * you generate it.  One secret key will be used for the entire application, and ideally should be generated by the person who starts the lobby.
     */
    public void generateSecretKey() {
        try {
            KeyGenerator keyGen = KeyGenerator.getInstance("AES");
            keyGen.init(keySize);
            secretKey = keyGen.generateKey();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Generate your own RSA public/private key pair.  You'll send your public key to a server when you connect,
     * then use your private key to decrypt the received secret key.  After that, these keys should not be used again.
     */
    public void generateKeys() {
        try {
            final KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
            generator.initialize(rsaKeySize);

            KeyPair keyPair = generator.generateKeyPair();

            privateKey = keyPair.getPrivate();
            publicKey = keyPair.getPublic();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Encrypt a message using the secret key.
     * @param message Byte array payload to encrypt.
     * @return The encrypted message plus IV as a byte array.
     */
    //Used Kirill's answer here: https://stackoverflow.com/questions/29575024/is-there-any-difference-if-i-init-aes-cipher-with-and-without-ivparameterspec
    //More on IVs: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
    public byte[] encryptMessageWithSecretKey(byte[] message)  {
        try {
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

            cipher.init(Cipher.ENCRYPT_MODE, secretKey, new SecureRandom());
            byte[] encryptedMessage = cipher.doFinal(message);

            //This should end up having a length of 16.
            byte[] generatedIv = cipher.getIV();
            byte[] payload = new byte[generatedIv.length + encryptedMessage.length];

            //Append the IV to the front
            System.arraycopy(generatedIv, 0, payload, 0, generatedIv.length);
            //Then the actual encrypted message to the back
            System.arraycopy(encryptedMessage, 0, payload, generatedIv.length, encryptedMessage.length);

            return payload;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Decrypt a message using the secret key.
     * @param encryptedMessage Byte array payload to decrypt.
     * @return The encrypted message plus IV as a byte array.
     */
    //Used Kirill's answer here: https://stackoverflow.com/questions/29575024/is-there-any-difference-if-i-init-aes-cipher-with-and-without-ivparameterspec
    //More on IVs: https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
    public byte[] decryptMessageWithSecretKey(byte[] encryptedMessage) {
        try {
            //Should be 16
            byte[] receivedIv = new byte[ivSize];
            byte[] encryptedData = new byte[encryptedMessage.length - receivedIv.length];

            //Pull out the IV
            System.arraycopy(encryptedMessage, 0, receivedIv, 0, receivedIv.length);
            //Pull out the actual encrypted data
            System.arraycopy(encryptedMessage, receivedIv.length, encryptedData, 0, encryptedData.length);

            //Get our cipher sorted
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(receivedIv));

            //Decrypt
            return cipher.doFinal(encryptedData);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Only used to encrypt the secret key for transmission.
     * @return The encrypted secret key.
     */
    public byte[] encryptSecretKeyWithPublicKey(PublicKey publicKey) {
        if(secretKey == null) return null;
        try {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);

            return cipher.doFinal(secretKey.getEncoded());
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Should be used ONLY when decrypting the received secret key.
     * @param message Message to decrypt.
     * @return Decrypted message as a byte array, probably/should be the secret key.
     */
    public byte[] decryptMessageWithPrivateKey(byte[] message) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.DECRYPT_MODE, this.privateKey);

            return cipher.doFinal(message);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void main( String[] args) throws Exception {
        Security.setProperty("crypto.policy", "unlimited");

        final Encryption agent1 = new Encryption();
        final Encryption agent2 = new Encryption();

        //Both generate their own sets of RSA keys
        agent1.generateKeys();
        agent2.generateKeys();

        //Agent 1 generates the AES secret key
        agent1.generateSecretKey();

        //Agent 1 encrypts the secret key using Agent 2's public key
        byte[] encryptedMessage = agent1.encryptSecretKeyWithPublicKey(agent2.getPublicKey());

        //Agent 2 decrypts the secret key using its private key
        byte[] receivedSecret = agent2.decryptMessageWithPrivateKey(encryptedMessage);

        int isSame = Arrays.compare(receivedSecret, agent1.secretKey.getEncoded());

        System.out.println("Received secret: " + Arrays.toString(receivedSecret));
        System.out.println("Original secret: " + Arrays.toString(agent1.secretKey.getEncoded()));

        agent2.secretKey = new SecretKeySpec(receivedSecret, 0, receivedSecret.length, "AES");

        String payload = "Look at me still talking when there's science to do...";
        System.out.println("Payload: " + payload);
        System.out.println("Payload bytes: " + Arrays.toString(payload.getBytes()));
        byte[] encryptedString = agent2.encryptMessageWithSecretKey(payload.getBytes());
        System.out.println("Encrypted string: " + Arrays.toString(encryptedString));

        byte[] decryptedBytes = agent1.decryptMessageWithSecretKey(encryptedString);
        System.out.println("Decrypted bytes: " + Arrays.toString(decryptedBytes));
        System.out.println("Decrypted string: " + new String(decryptedBytes));
    }

}
